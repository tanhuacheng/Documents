/*******************************************************************************************************/
创建一个 socket

    int socket (int domain, int type, int protocol);

    通信 domain

    +----------+------------+------------------------------+--------------------------------+-------+
    | Domain   | 执行的通信 | 应用程序间的通信             | 地址格式                | 地址结构     |
    +----------+------------+------------------------------+--------------------------------+-------+
    | AF_UNIX  | 内核中     | 同一主机                     | 路径名                  | sockaddr_un  |
    +----------+------------+------------------------------+--------------------------------+-------+
    | AF_INET  | 通过 IPv4  | 通过 IPv4 网络连接起来的主机 | IPv4 地址 + 16 位端口号 | sockaddr_in  |
    +----------+------------+------------------------------+--------------------------------+-------+
    | AF_INET6 | 通过 IPv6  | 通过 IPv6 网络连接起来的主机 | IPv6 地址 + 16 位端口号 | sockaddr_in6 |
    +----------+------------+------------------------------+--------------------------------+-------+

    socket 类型

        SOCK_STREAM: 提供一个可靠的双向的字节流通信信道
        SOCK_DGRAM: 以数据报的消息形式进行交换(保留了消息边界; 消息的到达可能是无序的, 重复的或者丢失的)

        在 Internet domain 中, SOCK_STREAM 使用 TCP, SOCK_DGRAM 使用 UDP.


/*******************************************************************************************************/
将 socket 绑定到地址: bind()

    int bind (int sockfd, const struct sockaddr* addr, socklen_t addrlen);

        sockfd 是 socket 调用中获得的文件描述符; addr 是一个指针, 它指向了一个指定该 socket 绑定到的地址
    的结构, 这个参数的类型取决于 domain; addrlen 指定了地址结构的大小;
        一般来讲, 会将一个服务器的 socket 绑定到一个众所周知的地址.

    通用 socket 地址结构: struct sockaddr

        struct sockaddr {
            sa_family_t sa_family;
            char sa_data[14];
        };


/*******************************************************************************************************/
监听接入连接: listen()

    int listen (int sockfd, int backlog);

        不能在已连接的 socket(已成功执行 connect() 的或由 accept() 调用返回的 socket) 上执行 listen().
        backlog 限制未决连接的数量(在调用 accept() 前, 客户端发起了 connect()).


/*******************************************************************************************************/
接受连接: accept()

    int accept (int sockfd, struct sockaddr* addr, socklen_t* addrlen);

        它会创建一个新的 socket, 正是这个新的 socket 与执行 connect() 的对等 socket 进行连接;


/*******************************************************************************************************/
连接到对等 socket: connect()

    int connect (int sockfd, const struct sockaddr* addr, socklen_t addrlen);

        如果 connect() 失败并且希望重新进行连接, 那么需要先关闭这个 socket, 创建一个新的 socket, 然后在
    该新的 socket 上重新进行连接.


